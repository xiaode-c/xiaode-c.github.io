<?xml version="1.0" encoding="UTF-8"?><rss version="2.0">
  <channel>
    <title>笔记</title>
    <link>http://localhost:9899/</link>
    <description>记录学习笔记的小站</description>
    <managingEditor> (gdb)</managingEditor>
    <pubDate>Sat, 28 May 2016 10:22:09 +0800</pubDate>
    <item>
      <title>python队列库Queue</title>
      <link>http://localhost/2016/5/11/python队列库Queue.html</link>
      <description>&lt;h1 id=&#34;queue&#34;&gt;Queue&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;Queue是python标准库中的线程安全的队列（FIFO）实现,提供了一个适用于多线程编程的先进先出的数据结构，即队列，用来在生产者和消费者线程之间的信息传递&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;基本fifo队列&#34;&gt;基本FIFO队列&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;class Queue.Queue(maxsize=0)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;FIFO即First in First Out,先进先出。Queue提供了一个基本的FIFO容器，使用方法很简单,maxsize是个整数，指明了队列中能存放的数据个数的上限。一旦达到上限，插入会导致阻塞，直到队列中的数据被消费掉。如果maxsize小于或者等于0，队列大小没有限制。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;举个栗子：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import Queue&#xA;&#xA;q = Queue.Queue()&#xA;&#xA;for i in range(5):&#xA;    q.put(i)&#xA;&#xA;while not q.empty():&#xA;    print q.get()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;0&#xA;1&#xA;2&#xA;3&#xA;4&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;lifo队列&#34;&gt;LIFO队列&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;class Queue.LifoQueue(maxsize=0)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;LIFO即Last in First Out,后进先出。与栈的类似，使用也很简单,maxsize用法同上&lt;/p&gt;&#xA;&#xA;&lt;p&gt;再举个栗子：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import Queue&#xA;&#xA;q = Queue.LifoQueue()&#xA;&#xA;for i in range(5):&#xA;    q.put(i)&#xA;&#xA;while not q.empty():&#xA;    print q.get()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;输出：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;4&#xA;3&#xA;2&#xA;1&#xA;0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;可以看到仅仅是将&lt;code&gt;Queue.Quenu类&lt;/code&gt;替换为&lt;code&gt;Queue.LifiQueue类&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;优先级队列&#34;&gt;优先级队列&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;class Queue.PriorityQueue(maxsize=0)&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;构造一个优先队列。maxsize用法同上。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;import Queue&#xA;import threading&#xA;&#xA;class Job(object):&#xA;    def __init__(self, priority, description):&#xA;        self.priority = priority&#xA;        self.description = description&#xA;        print &#39;Job:&#39;,description&#xA;        return&#xA;    def __cmp__(self, other):&#xA;        return cmp(self.priority, other.priority)&#xA;&#xA;q = Queue.PriorityQueue()&#xA;&#xA;q.put(Job(3, &#39;level 3 job&#39;))&#xA;q.put(Job(10, &#39;level 10 job&#39;))&#xA;q.put(Job(1, &#39;level 1 job&#39;))&#xA;&#xA;def process_job(q):&#xA;    while True:&#xA;        next_job = q.get()&#xA;        print &#39;for:&#39;, next_job.description&#xA;        q.task_done()&#xA;&#xA;workers = [threading.Thread(target=process_job, args=(q,)),&#xA;        threading.Thread(target=process_job, args=(q,))&#xA;        ]&#xA;&#xA;for w in workers:&#xA;    w.setDaemon(True)&#xA;    w.start()&#xA;&#xA;q.join()&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;结果&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;Job: level 3 job&#xA;Job: level 10 job&#xA;Job: level 1 job&#xA;for: level 1 job&#xA;for: level 3 job&#xA;for: job: level 10 job&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;一些常用方法&#34;&gt;一些常用方法&lt;/h2&gt;&#xA;&#xA;&lt;h3 id=&#34;task-done&#34;&gt;&lt;strong&gt;task_done()&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;意味着之前入队的一个任务已经完成。由队列的消费者线程调用。每一个get()调用得到一个任务，接下来的task_done()调用告诉队列该任务已经处理完毕。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如果当前一个join()正在阻塞，它将在队列中的所有任务都处理完时恢复执行（即每一个由put()调用入队的任务都有一个对应的task_done()调用）。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;join&#34;&gt;&lt;strong&gt;join()&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;阻塞调用线程，直到队列中的所有任务被处理掉。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;只要有数据被加入队列，未完成的任务数就会增加。当消费者线程调用task_done()（意味着有消费者取得任务并完成任务），未完成的任务数就会减少。当未完成的任务数降到0，join()解除阻塞。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;put-item-block-timeout&#34;&gt;&lt;strong&gt;put(item[, block[, timeout]])&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;将item放入队列中。&#xA;1. 如果可选的参数block为True且timeout为空对象（默认的情况，阻塞调用，无超时）。&#xA;2. 如果timeout是个正整数，阻塞调用进程最多timeout秒，如果一直无空空间可用，抛出Full异常（带超时的阻塞调用）。&#xA;3. 如果block为False，如果有空闲空间可用将数据放入队列，否则立即抛出Full异常&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其非阻塞版本为&lt;code&gt;put_nowait&lt;/code&gt;等同于&lt;code&gt;put(item, False)&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;get-block-timeout&#34;&gt;&lt;strong&gt;get([block[, timeout]])&lt;/strong&gt;&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;从队列中移除并返回一个数据。block跟timeout参数同&lt;code&gt;put&lt;/code&gt;方法&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其非阻塞方法为｀get_nowait()｀相当与&lt;code&gt;get(False)&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;empty&#34;&gt;empty()&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;如果队列为空，返回True,反之返回False&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Wed, 11 May 2016 22:01:28 +0000</pubDate>
    </item>
    <item>
      <title>docker学习笔记之容器</title>
      <link>http://localhost/2016/5/10/docker学习笔记之容器.html</link>
      <description>&lt;h2 id=&#34;启动容器&#34;&gt;启动容器&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;docker容器离不开docker镜像，容器以镜像为模板启动的，会在只读的镜像层上挂载一层可读写层，镜像本身是不变的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;启动一个新容器很简单&#xA;eg:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker run ubuntu:latest /bin/echo &amp;quot;hello world&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上命令运行一个容器，然后在容器中执行&lt;code&gt;/bin/echo &amp;quot;hello world&amp;quot;&lt;/code&gt;后终止容器&#xA;eg2:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker run -i -t ubuntu:latest /bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上会交互式的启动容器的bash,就像本地linux的终端一样，其中&lt;code&gt;-t&lt;/code&gt;指让docker分配一个伪终端，绑定到容器的标准输出上，&lt;code&gt;-i&lt;/code&gt;让容器的标准输出保持打开，这样就可以达到本地bash基本一样的效果&lt;/p&gt;&#xA;&#xA;&lt;p&gt;eg3:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker run -d ubuntu:latest /bin/bash&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以上称之为守护态运行，容器会在后台运行，返回该容器的id,可以使用&lt;code&gt;docker ps&lt;/code&gt;来查看正在运行的镜像，就可以看到在后台运行的容器.&lt;code&gt;docker logs　&amp;lt;contain_name&amp;gt;&lt;/code&gt;可以用来查看容器的日志信息&lt;/p&gt;&#xA;&#xA;&lt;p&gt;启动停止的容器&#xA;使用&lt;code&gt;docker ps -a&lt;/code&gt;可以查看当前所有的容器，找到你想启动的容器&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker start &amp;lt;container_id&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;终止容器&#34;&gt;终止容器&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;容器会在执行的应用终结后自动停止，若启动的是bash可通过exit退出&lt;/p&gt;&#xA;&#xA;&lt;p&gt;或者使用&lt;code&gt;docker stop&lt;/code&gt;直接终止运行中容器&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker stop &amp;lt;container_id&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;进入容器&#34;&gt;进入容器&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;当容器进入守护态后，有以下方法可以进入容器执行操作&#xA;- attach&#xA;- nsenter&#xA;- &amp;hellip;待补充&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;容器的导出和载入&#34;&gt;容器的导出和载入&lt;/h2&gt;&#xA;&#xA;&lt;h2 id=&#34;导出&#34;&gt;导出&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker export &amp;lt;导出文件名.tar&amp;gt; &amp;lt;container_name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;导入&#34;&gt;导入&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;从导出的&lt;strong&gt;容器&lt;/strong&gt;快照，载入为&lt;strong&gt;镜像&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo cat &amp;lt;导入文件名.tar&amp;gt; | docker import - &amp;lt;myimage&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;删除容器&#34;&gt;删除容器&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker rm &amp;lt;container_name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;:删除镜像用的是&lt;code&gt;docker rmi &amp;lt;image_name&amp;gt;&lt;/code&gt;,若要删除一个执行中的容器需要使用-f&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Tue, 10 May 2016 22:17:01 +0000</pubDate>
    </item>
    <item>
      <title>docker学习笔记之镜像</title>
      <link>http://localhost/2016/5/10/docker学习笔记之镜像.html</link>
      <description>&lt;h1 id=&#34;docker镜像&#34;&gt;Docker镜像&lt;/h1&gt;&#xA;&#xA;&lt;h2 id=&#34;获取镜像&#34;&gt;获取镜像&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;镜像下载的命令是：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker pull NAME[:TAG]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;NAME指镜像名，TAG指镜像标签,如不指定TAG，则下载最新镜像&lt;/p&gt;&#xA;&#xA;&lt;p&gt;例如，以下两个命令是相同的：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo docker pull ubuntu&#xA;sudo docker pull ubuntu:latest&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;也可以指定其它服务器的仓库&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo docker pull dl.dockerpool.com:5000/ubuntu&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;其中的&lt;code&gt;dl.dockerpool.com:5000&lt;/code&gt;就是注册服务器,默认的注册服务器是&lt;code&gt;registry.hub.docker.com&lt;/code&gt;,可以不写&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;查看本地镜像&#34;&gt;查看本地镜像&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo docker images&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;http://7xo1su.com1.z0.glb.clouddn.com/docker-images.png&#34; alt=&#34;docker-images&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;REPOSITORY: 表示来自于那个仓库&lt;/li&gt;&#xA;&lt;li&gt;TAG： 镜像的标签&lt;/li&gt;&#xA;&lt;li&gt;IMAGE ID： 镜像的ID号(镜像唯一标识)&lt;/li&gt;&#xA;&lt;li&gt;CREATED： 镜像创建时间&lt;/li&gt;&#xA;&lt;li&gt;SIZE： 镜像大小&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2 id=&#34;获取镜像详细信息&#34;&gt;获取镜像详细信息&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo docker inspect &amp;lt;镜像ID(前几个字符就行，只要能区分开)&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;搜寻镜像&#34;&gt;搜寻镜像&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;docker search&lt;/code&gt;用来搜索&#xA;参数：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    --automated=false   #仅显示自动常见的镜像&#xA;    --s, --stars=&amp;lt;num&amp;gt;   #显示几星级的镜像&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;创建镜像&#34;&gt;创建镜像&lt;/h2&gt;&#xA;&#xA;&lt;h3 id=&#34;基于已有容器创建镜像&#34;&gt;基于已有容器创建镜像&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在对正在运行中的容器进行更改之后，可以使用以下命令创建一个&lt;strong&gt;新镜像&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker commit [options] &amp;lt;running_container&amp;gt; [Resposity[:tag]]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;选项：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    -a, --author=&amp;quot;&amp;quot;   作者&#xA;    -m， --message=&amp;quot;&amp;quot;  提交说明信息&#xA;    -p, --pause=true   提交时暂停容器运行&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;创建成功后，返回镜像ID&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;基于dockerfile创建镜像&#34;&gt;基于Dockerfile创建镜像&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Docker基本语法&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;FROM        指定某个镜像为基础镜像&#xA;MAINTAINER     维护者&#xA;RUN            要在创建中运行的命令,安装软件&#xA;ADD            复制本地文件到镜像中&#xA;EXPOSE      向外部开放端口&#xA;CMD         容器启动后运行的命令，一个dockerfile只能有一个，多条只执行最后一条&#xA;ENV            设置环境变量&#xA;#            注释&#xA;...&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;简单例子：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;# Dockerfile&#xA;# This is my image&#xA;FROM ubuntu:latest&#xA;MAINTAINER your_name &amp;lt;your_email&amp;gt;&#xA;RUN apt-get update&#xA;RUN apt-get install vim&#xA;RUN cd ~&#xA;RUN touch README.txt&#xA;// 暴露容器的80端口&#xA;EXPOSE 80&#xA;CMD echo hello world&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;Docker写完之后，在当前目录下执行build命令来构建镜像，&lt;code&gt;-t&lt;/code&gt;用来添加标签&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker build -t=&amp;quot;mydockerimage&amp;quot; .&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;注意最后有一个点，指的是的Dockerfile所在目录，即当前目录下，可以换成其它&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;从本地导入&#34;&gt;从本地导入&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;还有一种方法就是从本地导入镜像，可以使用&lt;a href=&#34;http://openvz.org/Download/templates/precreated&#34;&gt;下载openvz的模板&lt;/a&gt;来创建&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然后使用import命令导入&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo cat &amp;lt;templates_name&amp;gt; | docker import - &amp;lt;myimage&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;添加标签&#34;&gt;添加标签&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;docker tag &amp;lt;IMAGE&amp;gt; &amp;lt;tagname&amp;gt;&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;镜像的导入和导出&#34;&gt;镜像的导入和导出&lt;/h2&gt;&#xA;&#xA;&lt;h3 id=&#34;导出镜像&#34;&gt;导出镜像&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker save -o &amp;lt;导出文件的名字.tar&amp;gt; &amp;lt;image_name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;导入镜像&#34;&gt;导入镜像&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker load --input &amp;lt;载入文件名字.tar&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;删除镜像&#34;&gt;删除镜像&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;docker rmi &amp;lt;tag&amp;gt;&lt;/code&gt; 只删除该标签的镜像&#xA;&lt;code&gt;docekr rmi &amp;lt;ID&amp;gt;&lt;/code&gt;  先删除该镜像的所有标签，然后删除镜像本身&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;删除前，需要删除该镜像的所有容器，若要强行删，使用-f&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2 id=&#34;上传镜像&#34;&gt;上传镜像&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用push上传镜像到共享仓库，需要先注册docker hub账号&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;docker push &amp;lt;image_name&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Tue, 10 May 2016 22:11:31 +0000</pubDate>
    </item>
    <item>
      <title>python之禅</title>
      <link>http://localhost/2016/5/8/python之禅.html</link>
      <description>&lt;h2 id=&#34;想必了解python的人-都知道在python的交互式命令行中-执行-import-this-会出现一首诗-这就是python之禅-我们应该争取能使自己做到以下这些&#34;&gt;想必了解python的人，都知道在python的交互式命令行中，执行&lt;code&gt;import this&lt;/code&gt;,会出现一首诗，这就是python之禅，我们应该争取能使自己做到以下这些&lt;/h2&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&lt;pre&gt;&lt;code&gt;Beautiful is better than ugly.&#xA;Explicit is better than implicit.&#xA;Simple is better than complex.&#xA;Complex is better than complicated.&#xA;Flat is better than nested.&#xA;Sparse is better than dense.&#xA;Readability counts.&#xA;Special cases aren&#39;t special enough to break the rules.&#xA;Although practicality beats purity.&#xA;Errors should never pass silently.&#xA;Unless explicitly silenced.&#xA;In the face of ambiguity, refuse the temptation to guess.&#xA;There should be one-- and preferably only one --obvious way to do it.&#xA;Although that way may not be obvious at first unless you&#39;re Dutch.&#xA;Now is better than never.&#xA;Although never is often better than *right* now.&#xA;If the implementation is hard to explain, it&#39;s a bad idea.&#xA;If the implementation is easy to explain, it may be a good idea.&#xA;Namespaces are one honking great idea -- let&#39;s do more of those!&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;: 以下是我的翻译，由于水平有限，可能有很多错误，慎重！！！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;美丽胜于丑陋&#xA;显式优于隐式&#xA;简洁胜于复杂&#xA;复杂胜于繁琐&#xA;扁平胜于嵌套&#xA;间隔胜于紧凑&#xA;可读性很重要&#xA;即便在特例的实用的情况下，也不应该违背这些规则&#xA;不要包容所有错误，除非你确定需要这样做&#xA;当存在多种可能，不要尝试去猜测&#xA;应该有一个 — — 并且最好只有一个 — — 明显的解决办法。&#xA;虽然这并不容易，因为你不是 Python 之父&#xA;如果你无法向别人描述你的方案，他就是个坏主意&#xA;如果很容易表述，那就是一个好方案&#xA;命名空间是一种绝妙的理念，我们应当多加利用&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Sun, 08 May 2016 19:15:37 +0000</pubDate>
    </item>
    <item>
      <title>ubuntu上使用genymotion</title>
      <link>http://localhost/2016/5/2/ubuntu上使用genymotion.html</link>
      <description>&lt;h2 id=&#34;安装virtuelbox&#34;&gt;安装virtuelbox&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install virtualbox-qt&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用时遇到以下问题&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;No suitable module for running kernel found&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;解决办法：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install virtualbox-source module-assistant&#xA;sudo m-a prepare&#xA;sudo m-a a-i virtualbox-source&#xA;sudo /etc/init.d/virtualbox restart&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;安装genymotion&#34;&gt;安装genymotion&lt;/h2&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;先到genymotion官网注册一个账号&lt;/li&gt;&#xA;&lt;li&gt;下载genymotion,到&lt;a href=&#34;https://www.genymotion.com/download&#34;&gt;https://www.genymotion.com/download&lt;/a&gt;下载对应系统的版本&lt;/li&gt;&#xA;&lt;li&gt;执行以下命令&#xA;&lt;code&gt;&#xA;    chmod +x &amp;lt;Genymotion download path&amp;gt;/genymotion-&amp;lt;version&amp;gt;_&amp;lt;arch&amp;gt;.bin&#xA;    cd &amp;lt;Genymotion download path&amp;gt;&#xA;    ./genymotion-&amp;lt;version&amp;gt;_&amp;lt;arch&amp;gt;.bin -d &amp;lt;Genymotion installer path&amp;gt;&#xA;&lt;/code&gt;&#xA;&lt;strong&gt;Genymotion download path&lt;/strong&gt;: genymotion的下载目录&#xA;&lt;strong&gt;Genymotion installer path&lt;/strong&gt;: genymotion的安装目录&#xA;&lt;strong&gt;genymotion -&lt;version&gt;_&lt;arch&gt;.bin&lt;/strong&gt;: 下载的genymotion安装包&lt;/li&gt;&#xA;&lt;li&gt;进入安装目录执行&lt;code&gt;./genymotion&lt;/code&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Mon, 02 May 2016 21:21:35 +0000</pubDate>
    </item>
    <item>
      <title>Zeal-linux版dash</title>
      <link>http://localhost/2016/4/29/Zeal-linux版dash.html</link>
      <description>&lt;p&gt;ZEAL 是一款离线文档浏览器,其灵感来自 OS X平台上的 Dash，目前支持 Window 和 Liunx。基于 QT5。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;主要功能&#34;&gt;主要功能：&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;可同时搜索多个文档&lt;/li&gt;&#xA;&lt;li&gt;不依赖网络&lt;/li&gt;&#xA;&lt;li&gt;GPL 协议开放源码&lt;/li&gt;&#xA;&lt;li&gt;Dash 中的文档都可以在 Zeal 中使用。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;到&lt;a href=&#34;zealdocs.org/download.html&#34;&gt;zeal的官网download页面&lt;/a&gt;，按照对应系统的方式安装&lt;/p&gt;&#xA;&#xA;&lt;p&gt;我用的是linux mint ,也就是按照ubuntu的安装方法安装：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;$ sudo add-apt-repository ppa:zeal-developers/ppa&#xA;$ sudo apt-get update&#xA;$ sudo apt-get install zeal&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装完成后，到&lt;code&gt;File&lt;/code&gt;--&amp;gt;&lt;code&gt;Options&lt;/code&gt;--&amp;gt;&lt;code&gt;Docsets&lt;/code&gt;中浏览下载你想要的文档。&#xA;下载后就可以搜索查找你想要的：&#xA;eg:&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;code&gt;string&lt;/code&gt; ：将会查找所有关于&lt;code&gt;string&lt;/code&gt;的文档&#xA;&lt;code&gt;python:string&lt;/code&gt;： 将会查找与&lt;code&gt;python&lt;/code&gt;有关的&lt;code&gt;string&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;效果&#34;&gt;效果&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;使用效果：&#xA;&lt;img src=&#34;http://7xo1su.com1.z0.glb.clouddn.com/zeal.png-hellopython&#34; alt=&#34;zeal效果&#34; /&gt;&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Fri, 29 Apr 2016 21:24:44 +0000</pubDate>
    </item>
    <item>
      <title>ubuntu安装配置sublime_text</title>
      <link>http://localhost/2016/4/29/ubuntu安装配置sublime_text.html</link>
      <description>&lt;p&gt;以前不愿意在ubuntu上使用sublime-text,就是因为不能输入中文的问题，当时查了查，也没找到什么靠谱的方法。于是就搁置了，最近，偶然间看到一个解决方法，就试了试，竟然成功了，有可以享受sublime的速度了，所以我就记录一下。(&lt;a href=&#34;http://www.sublimetext.com/&#34;&gt;sublime text官网&lt;/a&gt;)&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;安装sublime&#34;&gt;安装sublime&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo add-apt-repository ppa:webupd8team/sublime-text-3&#xA;sudo apt-get update&#xA;sudo apt-get install sublime-text-installer&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;在安装完成之后我们就可以正常使用了，下面解决中文输入的问题。&#xA;&lt;!--more--&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;解决无法输入中文的问题&#34;&gt;解决无法输入中文的问题&lt;/h2&gt;&#xA;&#xA;&lt;h3 id=&#34;安装好环境&#34;&gt;安装好环境&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install gtk+-2.0&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;新建文件-sublime-imfix-c&#34;&gt;新建文件：sublime_imfix.c&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;/*&#xA;sublime-imfix.c&#xA;Use LD_PRELOAD to interpose some function to fix sublime input method support for linux.&#xA;By Cjacker Huang&#xA;&#xA;gcc -shared -o libsublime-imfix.so sublime-imfix.c `pkg-config --libs --cflags gtk+-2.0` -fPIC&#xA;LD_PRELOAD=./libsublime-imfix.so subl&#xA;*/&#xA;#include &amp;lt;gtk/gtk.h&amp;gt;&#xA;#include &amp;lt;gdk/gdkx.h&amp;gt;&#xA;typedef GdkSegment GdkRegionBox;&#xA;&#xA;struct _GdkRegion&#xA;{&#xA;  long size;&#xA;  long numRects;&#xA;  GdkRegionBox *rects;&#xA;  GdkRegionBox extents;&#xA;};&#xA;&#xA;GtkIMContext *local_context;&#xA;&#xA;void&#xA;gdk_region_get_clipbox (const GdkRegion *region,&#xA;            GdkRectangle    *rectangle)&#xA;{&#xA;  g_return_if_fail (region != NULL);&#xA;  g_return_if_fail (rectangle != NULL);&#xA;&#xA;  rectangle-&amp;gt;x = region-&amp;gt;extents.x1;&#xA;  rectangle-&amp;gt;y = region-&amp;gt;extents.y1;&#xA;  rectangle-&amp;gt;width = region-&amp;gt;extents.x2 - region-&amp;gt;extents.x1;&#xA;  rectangle-&amp;gt;height = region-&amp;gt;extents.y2 - region-&amp;gt;extents.y1;&#xA;  GdkRectangle rect;&#xA;  rect.x = rectangle-&amp;gt;x;&#xA;  rect.y = rectangle-&amp;gt;y;&#xA;  rect.width = 0;&#xA;  rect.height = rectangle-&amp;gt;height;&#xA;  //The caret width is 2;&#xA;  //Maybe sometimes we will make a mistake, but for most of the time, it should be the caret.&#xA;  if(rectangle-&amp;gt;width == 2 &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(local_context)) {&#xA;        gtk_im_context_set_cursor_location(local_context, rectangle);&#xA;  }&#xA;}&#xA;&#xA;//this is needed, for example, if you input something in file dialog and return back the edit area&#xA;//context will lost, so here we set it again.&#xA;&#xA;static GdkFilterReturn event_filter (GdkXEvent *xevent, GdkEvent *event, gpointer im_context)&#xA;{&#xA;    XEvent *xev = (XEvent *)xevent;&#xA;    if(xev-&amp;gt;type == KeyRelease &amp;amp;&amp;amp; GTK_IS_IM_CONTEXT(im_context)) {&#xA;       GdkWindow * win = g_object_get_data(G_OBJECT(im_context),&amp;quot;window&amp;quot;);&#xA;       if(GDK_IS_WINDOW(win))&#xA;         gtk_im_context_set_client_window(im_context, win);&#xA;    }&#xA;    return GDK_FILTER_CONTINUE;&#xA;}&#xA;&#xA;void gtk_im_context_set_client_window (GtkIMContext *context,&#xA;          GdkWindow    *window)&#xA;{&#xA;  GtkIMContextClass *klass;&#xA;  g_return_if_fail (GTK_IS_IM_CONTEXT (context));&#xA;  klass = GTK_IM_CONTEXT_GET_CLASS (context);&#xA;  if (klass-&amp;gt;set_client_window)&#xA;    klass-&amp;gt;set_client_window (context, window);&#xA;&#xA;  if(!GDK_IS_WINDOW (window))&#xA;    return;&#xA;  g_object_set_data(G_OBJECT(context),&amp;quot;window&amp;quot;,window);&#xA;  int width = gdk_window_get_width(window);&#xA;  int height = gdk_window_get_height(window);&#xA;  if(width != 0 &amp;amp;&amp;amp; height !=0) {&#xA;    gtk_im_context_focus_in(context);&#xA;    local_context = context;&#xA;  }&#xA;  gdk_window_add_filter (window, event_filter, context);&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;编译成共享库&#34;&gt;编译成共享库&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;gcc -shared -o libsublime-imfix.so sublime_imfix.c  `pkg-config --libs --cflags gtk+-2.0` -fPIC&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;以下命令会打开sublime，查看是否可以输入中文&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;LD_PRELOAD=./libsublime-imfix.so subl&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;若可以，执行一下命令&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo mv libsublime-imfix.so /opt/sublime_text/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;修改-usr-share-applications-sublime-text-desktop&#34;&gt;修改/usr/share/applications/sublime-text.desktop&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo vi /usr/share/applications/sublime-text.desktop&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;我在进行这一步时，这个文件是不存在的，直接添加以下代码&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;[Desktop Entry]&#xA;.........&#xA;Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text %F&#xA;.........&#xA;&#xA;[Desktop Action Window]&#xA;.........&#xA;Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text -n&#xA;.........&#xA;&#xA;[Desktop Action Document]&#xA;.........&#xA;Exec=env LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so /opt/sublime_text/sublime_text --command new_file&#xA;.........&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;修改-usr-bin-subl&#34;&gt;修改 /usr/bin/subl：&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;将里面的内容替换为如下代码（要用管理员权限）&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;# !/bin/sh&#xA;export LD_PRELOAD=/opt/sublime_text/libsublime-imfix.so&#xA;exec /opt/sublime_text/sublime_text &amp;quot;$@&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;一些基本配置&#34;&gt;一些基本配置&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在&lt;code&gt;Preferences - Settings - User&lt;/code&gt;文件中里面加入。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;  &amp;quot;font_face&amp;quot;: &amp;quot;Dejavu Sans Mono&amp;quot;, //设置字体&#xA;  &amp;quot;font_size&amp;quot;: 12,  //设置字体大小&#xA;  &amp;quot;translate_tabs_to_spaces&amp;quot;: true,  //Tab对齐转化为空格对齐，tab_size 控制转化比例&#xA;  &amp;quot;tab_size&amp;quot;: 4,&#xA;  &amp;quot;trim_trailing_white_space_on_save&amp;quot;: true, //自动移除行尾多余空格&#xA;  &amp;quot;save_on_focus_lost&amp;quot;: true,  //窗口失去焦后立即保存文件&#xA;  &amp;quot;bold_folder_labels&amp;quot;: true, //侧栏文件夹加粗&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;一些好用的插件&#34;&gt;一些好用的插件&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;p&gt;Package Control&lt;/p&gt;&#xA;&#xA;&lt;p&gt;用来安装其它插件，安装方法可以去&lt;a href=&#34;https://packagecontrol.io/installation&#34;&gt;Package Control&lt;/a&gt;查看，注意Sublime Text的版本问题。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Emmet&lt;/p&gt;&#xA;&#xA;&lt;p&gt;前端神器&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;FileHeader&lt;/p&gt;&#xA;&#xA;&lt;p&gt;自动创建文件开头模板，并且会根据最后的保存时间修改更新时间&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;AllAutocomplete&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Sublime Text 默认的 Autocomplete 功能只考虑当前的文件，而 AllAutocomplete 搜索所有打开的文件来寻找匹配的词。&lt;/p&gt;&lt;/li&gt;&#xA;&#xA;&lt;li&gt;&lt;p&gt;Terminal&lt;/p&gt;&#xA;&#xA;&lt;p&gt;打开在当前文件所在的目录的终端，默认情况下，它设置按 Ctrl / Cmd + Shift + T 键的快捷方式打开终端。这也是&lt;strong&gt;打开上次关闭的文件&lt;/strong&gt;的快捷键，你需要修改快捷键来兼容两个功能&#xA;等等还有很多好用的插件，可以自行搜索&lt;/p&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Fri, 29 Apr 2016 21:09:36 +0000</pubDate>
    </item>
    <item>
      <title>Welcome</title>
      <link>http://localhost/2016/3/25/welcome.html</link>
      <description>&lt;p&gt;When you read the post, &lt;code&gt;PuGo&lt;/code&gt; is running successfully.&lt;/p&gt;&#xA;&#xA;&lt;p&gt;This post is generated from file &lt;code&gt;source/welcome.md&lt;/code&gt;. You can learn it and try to write your own article with following guide.&lt;/p&gt;&#xA;&#xA;&lt;h4 id=&#34;front-matter&#34;&gt;Front-Matter&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;Post&amp;rsquo;s front-matter, including title, author etc, are created by first code section with block &lt;strong&gt;```toml &amp;hellip;.. ```&lt;/strong&gt;:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-toml&#34;&gt;# post title, required&#xA;title = &amp;quot;Welcome&amp;quot;&#xA;&#xA;# post slug, use to build permalink and url, required&#xA;slug = &amp;quot;welcome&amp;quot;&#xA;&#xA;# post description, show in header meta&#xA;desc = &amp;quot;welcome to try pugo site generator&amp;quot;&#xA;&#xA;# post created time, support&#xA;# 2015-11-28, 2015-11-28 12:28, 2015-11-28 12:28:38&#xA;date = &amp;quot;2015-12-20 12:20:20&amp;quot;&#xA;&#xA;# post updated time, optional&#xA;# if null, use created time&#xA;update_date = &amp;quot;2015-12-20 12:30:30&amp;quot;&#xA;&#xA;# author identifier, reference to meta [[author]], required&#xA;author = &amp;quot;pugo&amp;quot;&#xA;&#xA;# tags, optional&#xA;tags = [&amp;quot;pugo&amp;quot;]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h4 id=&#34;content&#34;&gt;Content&lt;/h4&gt;&#xA;&#xA;&lt;p&gt;The content is data after first block. All words will be parsed as markdown content.&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code class=&#34;language-markdown&#34;&gt;&#xA;When you read the post, `PuGo` is running successfully.&#xA;&#xA;This post is generated from file `source/welcome.md`. You can learn it and try to write your own article with following guide.&#xA;&#xA;...... (markdown content)&#xA;&#xA;Markdown is a lightweight markup language with plain text formatting syntax designed&#xA;so that it can be converted to HTML and many other formats using a tool by the same name.&#xA;Markdown is often used to format readme files, for writing messages in online discussion forums,&#xA;and to create rich text using a plain text editor.&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <pubDate>Fri, 25 Mar 2016 12:20:20 +0000</pubDate>
    </item>
    <item>
      <title>Docker学习笔记一</title>
      <link>http://localhost/2016/3/21/Docker学习笔记一.html</link>
      <description>&lt;h2 id=&#34;docker的三个核心概念&#34;&gt;docker的三个核心概念&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;镜像(Image)&lt;/li&gt;&#xA;&lt;li&gt;容器(Container)&lt;/li&gt;&#xA;&lt;li&gt;仓库(Repository)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3 id=&#34;镜像&#34;&gt;镜像&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Docker镜像类似于虚拟机镜像，相当于Docker引擎的只读模板，Docker可以在镜像的基础上创建容器。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;容器&#34;&gt;容器&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;Docker容器是完整的文件系统，docker就是用它来运行应用，类似于轻量级的虚拟机，可以将其启动、开始、停止、删除等。容器从镜像启动时，docker会在镜像的最上层创建一个可写层。&#xA;&lt;!--more--&gt;&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;仓库&#34;&gt;仓库&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;docker仓库类似于github之类的代码仓库，是存放镜像文件的地方。docker仓库分为公开仓库（Docker Hub等）,私有仓库。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;安装docker&#34;&gt;安装docker&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我用的是ubuntu 14.04系统,安装docker很方便。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;which curl&#xA;#检查curl包有没有安装,如果curl没有安装的话，更新apt源之后，安装curl包。&#xA;&#xA;sudo apt-get update $ sudo apt-get install curl&#xA;#获得最新的docker安装包&#xA;&#xA;curl -sSL https://get.docker.com/ | sh &#xA;#shell会提示你输入sudo的密码，然后开始执行安装过程。&#xA;&#xA;sudo docker run hello-world&#xA;#确认Docker是否安装成功,这个命令会下载一个测试用的镜像并启动一个容器运行它。&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;windows下可以到官网&lt;a href=&#34;https://www.docker.com/&#34;&gt;https://www.docker.com/&lt;/a&gt;直接下载Boot2Docker&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Mon, 21 Mar 2016 15:12:30 +0000</pubDate>
    </item>
    <item>
      <title>python单例模式</title>
      <link>http://localhost/2016/3/20/python单例模式.html</link>
      <description>&lt;h2 id=&#34;单例模式&#34;&gt;单例模式&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;单例模式是一种常见的设计模式，在他的核心结构里只包含一个被称为单例的特殊类。这种模式可以保证系统中的一个类只有一个实例，并易于外部访问，从而控制实例个数节约系统资源。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;实现方式&#34;&gt;实现方式&lt;/h2&gt;&#xA;&#xA;&lt;h3 id=&#34;使用-new-方法&#34;&gt;使用&lt;strong&gt;new&lt;/strong&gt;方法&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Singleton(object):&#xA;    def __new__(cls, *args, **kw):&#xA;        if not hasattr(cls, &#39;_instance&#39;):&#xA;            orig = super(Singleton, cls)&#xA;            cls._instance = orig.__new__(cls, *args, **kw)&#xA;        return cls._instance&#xA;&#xA;class MyClass(Singleton):&#xA;    a = 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h3 id=&#34;共享属性&#34;&gt;共享属性&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;创建实例是把所有实例的&lt;strong&gt;dict&lt;/strong&gt;指向同一个字典，这样他们将拥有相同的属性和方法&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class Singleton(object):&#xA;    _state = {}&#xA;    def __new__(cls, *args, **kw):&#xA;        ob = super(Singleton, cls).__new__(cls, *args, **kw)&#xA;        ob.__dict__ = cls._state&#xA;        return ob&#xA;        &#xA;class MyClass(Singleton):&#xA;    a = 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;装饰器&#34;&gt;装饰器&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;def singleton(cls, *args, **kw):&#xA;    instances = {}&#xA;    def getinstance():&#xA;        if cls not in instances:&#xA;            instances[cls] = cls(*args, **kw)&#xA;        return instances[cls]&#xA;     return getinstance&#xA;     &#xA;@singleton&#xA;class MyClass:&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;模块&#34;&gt;模块&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;# singleton.py&#xA;class Singleton(object):&#xA;    def foo(self):&#xA;        pass&#xA;singleton = Singleton()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;使用&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;from singleton import singleton&#xA;singleton.foo()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;即singleton.py中的类Singleton只产生了一个实例。&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Sun, 20 Mar 2016 14:04:36 +0000</pubDate>
    </item>
    <item>
      <title>python的三种方法</title>
      <link>http://localhost/2016/3/19/python的三种方法.html</link>
      <description>&lt;h2 id=&#34;静态方法-类方法-实例方法的不同&#34;&gt;静态方法、类方法、实例方法的不同&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;首先来看一个类&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;#coding:utf-8&#xA;&#xA;class Fun():&#xA;    #实例方法&#xA;    def fun(self, x):&#xA;        print &amp;quot;executing fun(%s, %s)&amp;quot; % (self, x)&#xA;    #类方法&#xA;    @classmethod&#xA;    def class_fun(cls, x):&#xA;        print &amp;quot;executing class_fun(%s, %s)&amp;quot; % (cls, x)&#xA;    &#xA;    #静态方法&#xA;    @staticmethod&#xA;    def static_fun(x):&#xA;        print &amp;quot;executing static_fun(%s)&amp;quot; % x&#xA;&#xA;f = Fun()&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上面self指的是实例， cls指的是类，也就是说实例方法是绑定了实例的，因此必须由实例来调用它；而类方法是绑定这类的。而静态方法谁都没绑定，与类外的普通方法很像，只不过需要用f或Fun来调用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;如下&lt;/p&gt;&#xA;&#xA;&lt;table&gt;&#xA;&lt;thead&gt;&#xA;&lt;tr&gt;&#xA;&lt;th&gt;&lt;/th&gt;&#xA;&lt;th&gt;column&lt;/th&gt;&#xA;&lt;th&gt;column&lt;/th&gt;&#xA;&lt;th&gt;column&lt;/th&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/thead&gt;&#xA;&#xA;&lt;tbody&gt;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;f=Fun()&lt;/td&gt;&#xA;&lt;td&gt;f.fun(x)&lt;/td&gt;&#xA;&lt;td&gt;f.class_fun(x)&lt;/td&gt;&#xA;&lt;td&gt;f.statis_fun(x)&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&#xA;&lt;tr&gt;&#xA;&lt;td&gt;Fun&lt;/td&gt;&#xA;&lt;td&gt;不可用&lt;/td&gt;&#xA;&lt;td&gt;Fun.class_fun(x)&lt;/td&gt;&#xA;&lt;td&gt;Fun.statis_fun(x)&lt;/td&gt;&#xA;&lt;/tr&gt;&#xA;&lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Sat, 19 Mar 2016 23:38:15 +0000</pubDate>
    </item>
    <item>
      <title>sae上mysql问题</title>
      <link>http://localhost/2016/3/19/sae上mysql问题.html</link>
      <description>&lt;h2 id=&#34;mysql数据库问题&#34;&gt;mysql数据库问题&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我在sae上部署自己写的flask应用时，有时会出现&lt;code&gt;OperationalError: (OperationalError) (2006, &#39;MySQL server has gone away&#39;) &#39;SELECT entry.id AS entry_id, entry.name AS entry_name, entry.description AS entry_description, entry.content AS entry_content, entry.created AS entry_created \nFROM entry \nWHERE entry.id = %s \n LIMIT %s&#39; (3, 1)&lt;/code&gt;等一些问题。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;可能原因&#34;&gt;可能原因&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;在网上查了一下原因，有一下几点：&lt;/p&gt;&#xA;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;MySQL 服务宕了&lt;/li&gt;&#xA;&lt;li&gt;MySQL连接超时&lt;/li&gt;&#xA;&lt;li&gt;mysql请求链接进程被主动kill&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;解决方法&#34;&gt;解决方法&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;经过查询和尝试，找到了一种解决方案，代码如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;class nullpool_SQLAlchemy(SQLAlchemy):&#xA;    def apply_driver_hacks(self, app, info, options):&#xA;        super(nullpool_SQLAlchemy, self).apply_driver_hacks(app, info, options)&#xA;        from sqlalchemy.pool import NullPool&#xA;        options[&#39;poolclass&#39;] = NullPool&#xA;        del options[&#39;pool_size&#39;]&#xA;&#xA;db = nullpool_SQLAlchemy()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;需要将&lt;code&gt;db=SQLAlchemy()&lt;/code&gt;改为&lt;code&gt;db = nullpool_SQLAlchemy()&lt;/code&gt;&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Sat, 19 Mar 2016 12:38:34 +0000</pubDate>
    </item>
    <item>
      <title>nrm详细使用</title>
      <link>http://localhost/2016/3/18/nrm详细使用.html</link>
      <description>&lt;h2 id=&#34;nrm简介&#34;&gt;nrm简介&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;nrm是npm源的管理工具，可以非常方便的切换各种源，因为墙的存在，我们在安装node包时非常慢，这时nrm就排上用场了。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;nrm安装&#34;&gt;nrm安装&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;    npm install -g nrm&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;nrm使用&#34;&gt;nrm使用&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;    nrm ls&#xA;    #列出可用的npm源&#xA;&#xA;   *npm ---- https://registry.npmjs.org/&#xA;    cnpm --- http://r.cnpmjs.org/&#xA;    taobao - http://registry.npm.taobao.org/&#xA;    eu ----- http://registry.npmjs.eu/&#xA;    au ----- http://registry.npmjs.org.au/&#xA;    sl ----- http://npm.strongloop.com/&#xA;    nj ----- https://registry.nodejitsu.com/&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;*&lt;strong&gt;代表当前的源&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;测试源的速度&#34;&gt;测试源的速度&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;    nrm test&#xA;    &#xA;    npm ---- 891ms&#xA;    cnpm --- 1213ms&#xA;   *taobao - 460ms&#xA;    eu ----- 3859ms&#xA;    au ----- 1073ms&#xA;    sl ----- 4150ms&#xA;    nj ----- 8008ms&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;nrm切换源&#34;&gt;nrm切换源&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;    nrm use cnpm&#xA;    #切换到cnpm源&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;nrm增加源&#34;&gt;nrm增加源&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;    nrm add  &amp;lt;registry&amp;gt; &amp;lt;url&amp;gt; [home]&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;nrm删除源&#34;&gt;nrm删除源&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;    nrm del &amp;lt;registry&amp;gt;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Fri, 18 Mar 2016 15:21:20 +0000</pubDate>
    </item>
    <item>
      <title>python包之psutil</title>
      <link>http://localhost/2016/3/17/python包之psutil.html</link>
      <description>&lt;p&gt;psutil是python的一个很有用的模块，可以用来查看系统的各种状态信息，包括内存，磁盘，网络，进程，cpu等的使用情况。能实现linux上ps、top、lso、nice、netstat、ifconfig、who、df、kill、freeionice、iostat、iotop、uptime等命令的功能。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;下载安装&#34;&gt;下载安装&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;psutil在使用前，必须安装，下载地址为&lt;a href=&#34;https://pypi.python.org/simple/psutil/&#34;&gt;https://pypi.python.org/simple/psutil/&lt;/a&gt;选择对应版本下载即可，安装过程很简单，就是下一步一直到完成。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;或者&lt;/p&gt;&#xA;&#xA;&lt;p&gt;直接使用&lt;code&gt;pip install psutil&lt;/code&gt;安装&lt;/p&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;基本使用&#34;&gt;基本使用&lt;/h2&gt;&#xA;&#xA;&lt;h3 id=&#34;获取cpu的信息&#34;&gt;获取cpu的信息&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    #显示cpu的整个信息&#xA;    import psutil&#xA;    psutil.cpu_times()&#xA;    &#xA;    #获取其中单项值，例如：&#xA;    psutil.cpu_times() .user&#xA;    &#xA;    #获取cpu的逻辑个数&#xA;    psutil.cpu_count()&#xA;    &#xA;    #获取cpu的物理个数&#xA;    psutil.cpu_count(logical=False)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;读取内存信息&#34;&gt;读取内存信息&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;主要可以获取系统内存利用率信息涉及&lt;code&gt;total&lt;/code&gt;(内存总数)，&lt;code&gt;used&lt;/code&gt;(以使用内存)，free(空闲内存)，&lt;code&gt;buffers&lt;/code&gt;(缓冲使用数)， &lt;code&gt;cache&lt;/code&gt;(缓存使用数)，&lt;code&gt;swap&lt;/code&gt;(交换分区使用数)&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    #获取内存的完整信息&#xA;    mem = psuti.virtual_memory()&#xA;    &#xA;    #获取内存总数&#xA;    mem.total   &#xA;    &#xA;    #获取空闲的内存信息&#xA;    mem.free        &#xA;    &#xA;    #获取swap分区信息&#xA;    psutil.swap_memory()&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;获取磁盘信息&#34;&gt;获取磁盘信息&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;&#xA;    #获取磁盘的完整信息&#xA;    psutil.disk_partitions()&#xA;    &#xA;    #获取分区表的参数&#xA;    psutil.disk_usage(&#39;/&#39;)&#xA;       &#xA;    #获取硬盘IO总个数&#xA;    psutil.disk_io_counters()&#xA;    &#xA;    #获取单个分区IO个数，perdisk=True参数获取单个分区IO个数&#xA;    psutil.disk_io_counters(perdisk=True)  &#xA;    &#xA;    #磁盘利用率使用&#xA;    psutil.disk_usage &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;读取网络信息&#34;&gt;读取网络信息&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;其中有几个参数&#xA;&lt;code&gt;Bytes_sent&lt;/code&gt;，发送字节数&#xA;&lt;code&gt;Packets_sent&lt;/code&gt;，接收字节数&#xA;&lt;code&gt;Packets_sent&lt;/code&gt;，发送数据包数&#xA;&lt;code&gt;Packets_sent&lt;/code&gt;，接收数据包数&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    #获取网络总IO信息&#xA;    psutil.net_io_counters()   &#xA;    &#xA;    #pernic=True输出网络每个接口信息&#xA;    psutil.net_io_counters(pernic=True)     &#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;获取当前系统用户登录信息&#34;&gt;获取当前系统用户登录信息&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    #获取开机时间&#xA;    psutil.users()&#xA;&#xA;    import psutil, datetime&#xA;    psutil.boot_time()    &#xA;    datetime.datetime.fromtimestamp(psutil.boot_time()).strftime(&amp;quot;%Y-%m-%d %H: %M: %S&amp;quot;) #转换成自然时间格式&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h3 id=&#34;系统进程管理&#34;&gt;系统进程管理&lt;/h3&gt;&#xA;&lt;pre&gt;&lt;code&gt;    #查看系统全部进程&#xA;    psutil.pids()&#xA;    &#xA;    #查看单个进程,例如，2423是进程号&#xA;    p = psutil.Process(2423) &#xA;    p.name()   #进程名&#xA;    p.exe()    #进程的bin路径&#xA;    p.cwd()    #进程的工作目录绝对路径&#xA;    p.status()   #进程状态&#xA;    p.create_time()  #进程创建时间&#xA;    p.uids()    #进程uid信息&#xA;    p.gids()    #进程的gid信息&#xA;    p.cpu_times()   #进程的cpu时间信息,包括user,system两个cpu信息&#xA;    p.cpu_affinity()  #get进程cpu亲和度,如果要设置cpu亲和度,将cpu号作为参考就好&#xA;    p.memory_percent()  #进程内存利用率&#xA;    p.memory_info()    #进程内存rss,vms信息&#xA;    p.io_counters()    #进程的IO信息,包括读写IO数字及参数&#xA;    p.connectios()   #返回进程列表&#xA;    p.num_threads()  #进程开启的线程数&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;更多内容请看&lt;a href=&#34;http://pythonhosted.org/psutil/&#34;&gt;官方文档&lt;/a&gt;&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Thu, 17 Mar 2016 20:43:40 +0000</pubDate>
    </item>
    <item>
      <title>ubuntu安装node</title>
      <link>http://localhost/2016/3/17/ubuntu安装node.html</link>
      <description>&lt;p&gt;学习一下node.js，感受一下不同的编程风格，我用的是ubuntu系统。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;安装版本管理器&#34;&gt;安装版本管理器&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装node.js版本管理工具，这里我选择的是&lt;a href=&#34;https://github.com/tj/n&#34;&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    git clone https://github.com/tj/n.git&#xA;    cd n&#xA;    make install&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;安装node-js&#34;&gt;安装node.js&lt;/h2&gt;&#xA;&lt;pre&gt;&lt;code&gt;    n + (node.js的版本号)&#xA;    eg: n 4.2.1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;安装nrm&#34;&gt;安装nrm&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;安装nrm,npm源的管理工具可以很方便的切换源，很适合在国内这种情况下使用。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;    npm install -g nrm&#xA;    &#xA;    #显示可选的源&#xA;    nrm ls&#xA;    &#xA;    #测式各个npm的速度&#xA;    nrm test&#xA;    &#xA;    #切换源&#xA;    eg:&#xA;      nrm use taobao&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Thu, 17 Mar 2016 20:28:34 +0000</pubDate>
    </item>
    <item>
      <title>安装配置oh-my-zsh</title>
      <link>http://localhost/2016/3/16/安装配置oh-my-zsh.html</link>
      <description>&lt;h2 id=&#34;安装&#34;&gt;安装&lt;/h2&gt;&#xA;&#xA;&lt;h3 id=&#34;安装zsh&#34;&gt;安装zsh&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;oh-my-zsh是一个zsh shell的框架。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;安装oh-my-zsh前需安装zsh&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sudo apt-get install zsh&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;检查zsh是否正确安装&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;zsh --version&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;应输出&lt;code&gt;zsh 5.0.5 or 更高版本&lt;/code&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;设置zsh为你的默认shell:&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;chsh -s $(which zsh)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h3 id=&#34;安装oh-my-zsh&#34;&gt;安装oh-my-zsh&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;使用以下命令安装oh-my-zsh&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;或者&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;sh -c &amp;quot;$(wget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&amp;quot;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;&#xA;&#xA;&lt;h3 id=&#34;更改主题&#34;&gt;更改主题&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;在用户家目录下有一个&lt;code&gt;.zshrc&lt;/code&gt;文件，是zsh的配置文件。设置&lt;code&gt;ZSH_THEME=&amp;quot;ys&amp;quot;&lt;/code&gt;来设置主题，这里我用的是ys主题，主题的目录在&lt;code&gt;~/.oh-my-zsh/themes&lt;/code&gt;,大部分的主题在你安装oh-my-zsh时都已经下载到本地了。&lt;/p&gt;&#xA;&#xA;&lt;h3 id=&#34;使用插件&#34;&gt;使用插件&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;同样是在&lt;code&gt;.zshrc&lt;/code&gt;文件中，设置&lt;code&gt;plugins=(git command-not-found)&lt;/code&gt;,要使用插件直接将它的名字加到括号中，以空格隔开。插件的目录在&lt;code&gt;~/.oh-my-zsh/plugins&lt;/code&gt;,在你安装oh-my-zsh时插件也都已经下载到本地了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;更多详细的配置见oh-my-zsh官网&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Wed, 16 Mar 2016 20:41:19 +0000</pubDate>
    </item>
    <item>
      <title>在sae上部署应用</title>
      <link>http://localhost/2016/3/16/在sae上部署应用.html</link>
      <description>&lt;h1 id=&#34;在sae上部署应用&#34;&gt;在sae上部署应用&lt;/h1&gt;&#xA;&#xA;&lt;p&gt;首先新建一个应用（python为例）,然后使用git或者svn工具来创建一个版本假设您刚刚创建了应用newapp。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;创建应用&#34;&gt;创建应用&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;首先，创建一个新的Git仓库并且添加一个Git远程仓库sae，地址为：&lt;a href=&#34;https://git.sinacloud.com/newapp&#34;&gt;https://git.sinacloud.com/newapp&lt;/a&gt;。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;mkdir newapp &amp;amp;&amp;amp; cd newapp&#xA;git init&#xA;git remote add sae https://git.sinacloud.com/newapp&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;!--more--&gt;&#xA;&#xA;&lt;h2 id=&#34;上传代码&#34;&gt;上传代码&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;如部署Git的主分支（master）的代码到SAE服务器上的版本1中,操作如下：&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;touch index.wsgi config.yaml&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;添加内容&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;config.yaml&#xA;&#xA;name: helloworld&#xA;version: 1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&lt;pre&gt;&lt;code&gt;index.wsgi&#xA;&#xA;import sae&#xA;&#xA;def app(environ, start_response):&#xA;    status = &#39;200 OK&#39;&#xA;    response_headers = [(&#39;Content-type&#39;, &#39;text/plain&#39;)]&#xA;    start_response(status, response_headers)&#xA;    return [&#39;Hello, world!&#39;]&#xA;&#xA;application = sae.create_wsgi_app(app)&#xA;&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;上传&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;git add .&#xA;git commit -m &amp;quot;initial commit&amp;quot;&#xA;git push sae master:1&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;若要从SAE服务器上删除版本1的代码。&#xA;     git push sae :1&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;SAE上的Python应用的入口为 index.wsgi:application ，也就是 index.wsgi 这个文件中名为 &lt;strong&gt;application&lt;/strong&gt;的可调用对象。在helloworld应用中，该application为一个wsgi的可调用对象。&lt;/p&gt;&#xA;&#xA;&lt;h2 id=&#34;部署新版本&#34;&gt;部署新版本&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;提交刚刚编辑的代码，就可以完成应用在SAE上的部署。&lt;/p&gt;&#xA;&lt;pre&gt;&lt;code&gt;git add file&#xA;git commit -m &amp;quot;info&amp;quot;&#xA;git push sae master:2&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Wed, 16 Mar 2016 17:34:21 +0000</pubDate>
    </item>
    <item>
      <title>本站第一篇文章</title>
      <link>http://localhost/2016/3/16/本站第一篇文章.html</link>
      <description>&lt;h2 id=&#34;本站介绍&#34;&gt;本站介绍&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;本站是用来记录我的学习笔记的地方，分享我在学习过程中遇到的问题与收获。还会分享一些，我在学习过程中搜集的一些资源,&lt;strong&gt;本站采用的是hexo静态博客系统，部署在sae上&lt;/strong&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;欢迎大家来互相学习。&lt;/p&gt;&#xA;</description>
      <author>gdb</author>
      <pubDate>Wed, 16 Mar 2016 16:45:39 +0000</pubDate>
    </item>
  </channel>
</rss>